<!DOCTYPE html>
<html lang="en" style="width: 100%; height: 100%; margin: 0; padding: 0; border: 0">

<head>
  <meta charset="utf-8" />
  <base target="“_blank”" />
  <script src="/widgets/cc-baselib/static/vue.js"></script>
  <script src="/widgets/cc-baselib/static/element-ui/index.js"></script>
  <script src="/widgets/cc-baselib/static/axios.min.js"></script>
  <script src="/widgets/cc-baselib/static/vue-clipboard.min.js"></script>
  <script src="/widgets/cc-baselib/static/vue-router.js"></script>
  <script src="/widgets/cc-baselib/static/httpVueLoader.js"></script>
  <script src="/widgets/cc-baselib/static/jszip.min.js"></script>
  <script src="/widgets/cc-baselib/static/Sortable.min.js"></script>
  <script src="/widgets/cc-baselib/static/vue-draggable-resizeable/VueDraggableResizable.umd.min.js"></script>
  <script src="/widgets/cc-baselib/src/commonFunctionsForSiyuan.js"></script>
  <script src="/widgets/cc-baselib/src/siYuanApi.js"></script>
  <script src="/widgets/cc-baselib/src/componentsList.js"></script>
  <script src="/widgets/cc-baselib/static/vditor/index.min.js"></script>
  <link rel="stylesheet" href="/widgets/cc-baselib/static/vditor/index.css" />
  <link rel="stylesheet" href="/widgets/cc-baselib/static/element-ui/theme-chalk/index.css" />
  <link rel="stylesheet" href="/widgets/cc-baselib/static/vue-draggable-resizeable/VueDraggableResizable.css" />
  <link id="themeDefaultStyle" />
</head>

<body>
  <div id="app" style="width: 100vw; height: 100vw" v-on:mousemove="计算坐标($event)" v-on:paste="黏贴内容($event)">
    <cc-dragable-block-card v-if="item" :key="标记数组[i]['id']" v-model="标记数组[i]" :index="i" @activated="当前激活标签序号=i"
      @callbacklink="展开链接面板(i)" @calloutgoinglinks="获取正向链接(i)" @startlink="等待连接 = true" v-for="(item,i) in 标记数组"
      @delete="移除标签(i)"></cc-dragable-block-card>
    <div :style="`position: absolute; width: ${窗口大小.width}px; height:${窗口大小.height}px; `" v-on:paste="黏贴内容($event)"
      v-on:mousemove="计算坐标($event)">

    </div>
    <svg ref="background" :style="`position: absolute; width: ${窗口大小.width}px; height: ${窗口大小.height}px; `"
      :width="窗口大小.width" :height="窗口大小.height" @click="增加标记()" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <marker id='markerArrowTo' markerWidth='40' markerHeight='40' refx='10' refy='6' orient='auto'>
          <path d='M2,2 L2,11 L10,6 L2,2' style='fill:black' />
        </marker>
        <marker id='markerArrowFrom' markerWidth='40' markerHeight='40' refx='2' refy='6' orient='auto'>
          <path d='M2,2 L2,11 L10,6 L2,2' style='fill:black' />
        </marker>
      </defs>
      <path v-for="(link,i) in links" v-if="link" v-bind:d='计算折线路径(link)["d"]||""' marker-mid='url(#markerArrowFrom)'
        marker-start='url(#markerArrowFrom)' marker-end='url(#markerArrowTo)' :stroke="link['color']||'black'"
        :storke-width="link['width']||1" fill="transparent" />
      <foreignObject v-for="(link,i) in links" xmlns="http://www.w3.org/2000/svg" :y="`${计算折线路径(link)['mid']['y']}`"
        :x="`${计算折线路径(link)['mid']['x']-50}`" :height="50" :width="100">
        <el-row>
          <el-input v-model="link.label" size="mini"></el-input>
          <el-popover trigger="hover" width="300">
            <span slot="reference" class="el-icon-link"></span>
            <cc-color-pane v-model="link.color"></cc-color-pane>
          </el-popover>

        </el-row>
      </foreignObject>
    </svg>

    <el-card v-if='false' body-style="border:solid 1px;
          top: 10px;
            padding:0px;
            border-radius:5px;
            position: fixed;
            background-color:white ;
            width: 400px;z-index:251">
      <el-input size="mini" v-model="当前块引" @change="设定当前标记()"><span slot="prepend">来源块</span></el-input>
      <cc-block-attr-form :内容块id="当前块引" :是否显示基础属性="true" :是否显示源属性名="false" :是否显示原始自定义属性="false" :是否显示自定义属性="true"
        :新属性模板="新属性" :属性类型="属性类型" :书签列表="书签列表" :主界面="主界面"></cc-block-attr-form>

    </el-card>
    <image @click="增加标记()" @contextmenu.prevent="打开右键菜单()" style="width: 100%; height: 100%" :src="内部图片源" fit="contain"
      ref="image">
    </image>

    <el-card body-style="border:solid 1px;
        border-radius:5px;
        position: fixed;
        top:calc(100vh - 100px);
        left:calc(50vw - 300px);
        background-color:white ;
        z-index:251;
        padding:5px;
        width:600px">
      <el-row>
        <el-col :span="6">

          <el-popover trigger="click">
            <el-input v-model="内部图片源" size="mini"></el-input>
            <cc-assets-selector v-model="图片源" :apitoken="apitoken" :思源伺服ip="思源伺服ip" :k="图片格式"></cc-assets-selector>

            <el-select v-model="图片格式" size="mini" allow-create filterable>
              <el-option v-for="格式 in 格式列表" :label="格式" :value="格式">
              </el-option>
            </el-select>
            <div slot="reference" class="el-icon-picture"></div>
            <div slot="reference" class="el-icon-picture"></div>
          </el-popover>
          <div class="el-icon-plus" @click="定点添加=true"></div>
          <span v-if="定点添加"
            :style="`position:absolute;left:${当前鼠标坐标.x+30}px;top: ${当前鼠标坐标.y+30}px;z-index:251`">点击添加标签</span>
          <el-popover trigger="hover">
            <div slot="reference" class="el-icon-zoom-in"></div>
            <el-input-number size="mini" type="number" v-model="图片缩放倍数" :min="0.1" :max="100" :step="0.1">
            </el-input-number>
            <el-switch v-model="协同缩放" active-text="同时缩放标签坐标"></el-switch>
          </el-popover>
          <el-popover trigger="hover">
            <div slot="reference" class="el-icon-help"></div>
            <div v-for="不可见标记 in 不可见标记数组" @click="定位至标记(不可见标记)">
              标签{{不可见标记.index}}坐标:{{不可见标记.left}}|{{不可见标记.top}}
            </div>
          </el-popover>
          <el-popover trigger="hover">
            <div slot="reference" class="el-icon-browser" @click="打开新窗口()"></div>
            <el-input v-model="数据源id" :disabled="$挂件模式()"><span slot="prepend">数据源id:</span>
            </el-input>
          </el-popover>
        </el-col>
        <el-col :span="6">

        </el-col>
        <el-col :span="2">
          <el-popover trigger="click" width="350">
            <div slot="reference" :style="`
                  color:${当前文字色};
                  font-weight:bolder;
                  text-decoration:underline 4px;
                  text-align:center;
                  `">
              A
            </div>
            <h3>文字</h3>

            <cc-color-pane v-model="当前文字色" @change="设定当前标记()" :自定义颜色数组="自定义颜色数组"></cc-color-pane>
          </el-popover>
        </el-col>
        <el-col :span="2">
          <el-popover trigger="click" width="350">
            <div slot="reference" :style="`background-color:${当前背景色};
                        width:24px;
                        height:24px;
                        border:solid 1px;
                        margin:2px`"></div>
            <h3>背景</h3>

            <cc-color-pane v-model="当前背景色" @change="设定当前标记()" :自定义颜色数组="自定义颜色数组"></cc-color-pane>
          </el-popover>
        </el-col>
        <el-col :span="2">
          <el-popover trigger="click" width="350">
            <div slot="reference"
              :style="`background-color:'';width:24px;height:24px;outline:solid 3px ${当前边框色};margin:2px`"></div>
            <h3>边框</h3>
            <cc-color-pane v-model="当前边框色" @change="设定当前标记()" :自定义颜色数组="自定义颜色数组"></cc-color-pane>
          </el-popover>
        </el-col>
        <span style="font-size:xx-small"
          v-if="当前激活标签序号">标签{{当前激活标签序号}}坐标:{{标记数组[当前激活标签序号].left}}|{{标记数组[当前激活标签序号].top}}</span>
      </el-row>
    </el-card>
    <el-card body-style="border-radius:5px;
                    padding:10px;
                    border:solid black 1px;
                    position: fixed;
                    background-color:white ;
                    position: fixed;top:10px;
                    left:calc(100vw - 250px);
                    width:200px;
                    height:200x;
                    max-height:90%;
                    max-width:200px;
                    z-index:252;
                    overflow:scroll;
                    resize:vertical
                    ">
      <span style="font-size: xx-small" @click="定位至标记(标记数组[当前反向链接列表['index']])" v-if="当前反向链接列表['index']>0">
        标签{{当前反向链接列表.index}}坐标:{{标记数组[当前反向链接列表['index']].left}}|{{标记数组[当前反向链接列表['index']].top}}
      </span>
      <cc-block-list :blocklist="当前反向链接列表['backlinks']" title="反向链接" :count="当前反向链接列表['linkRefsCount']"></cc-block-list>
      <el-divider></el-divider>

      <cc-block-list :blocklist="当前反向链接列表['backmentions']" :count="当前反向链接列表['mentionsCount']" title="提及">
      </cc-block-list>
      <cc-block-list :blocklist="当前正向链接列表" :count="当前正向链接列表.length" title="正向链接"></cc-block-list>
    </el-card>
    <div :style="`position:absolute;top:${窗口大小.height}px;left:${窗口大小.width}px;width:10px;height:10px`"></div>


  </div>


  </div>
</body>
<script src="/stage/protyle/js/lute/lute.min.js"></script>

<script>
  Vue.use(httpVueLoader);
  Vue.use(VueDraggableResizable);

  Vue.component("vue-draggable-resizable", VueDraggableResizable);
  var vm = new Vue({
    el: "#app",
    components: componentList,
    mounted: async function () {
      this.主界面 = window.parent.document;
      this.思源伺服ip = window.location.host;
      console.log(this.思源伺服ip)
      this.$获取书签列表()

      await this.初始化();

    },
    data() {
      return {
        书签列表: "",
        新属性: { "type": "原始文本", "name": "newattr", "label": "newattr", "value": "default" },
        属性类型: ["图片", "文本", "块链接", "超链接", "原始文本", "附件"],

        等待连接: "",
        数据源id: "",
        协同缩放: false,
        窗口大小: {},
        主界面: {},
        内部图片源: "",
        图片源: "",
        图片格式: "jpg",
        思源伺服ip: "",
        apitoken: "",
        格式列表: ["jpg", "png", "jpeg"],
        挂件自身元素: "",
        标记数组: [
          {
            index: 0,
            def_block: "",
            anchor: "锚文本为空时显示来源块内容",
            top: 100,
            left: 100,
            width: 100,
            height: 100,
            color: "black",
            backgroundColor: "yellow",
            borderColor: "red",
            showhandler: false,
            folded: true,
          },
        ],
        图片数组: [
          {
            filepath: "",
            url: "",
            top: 200,
            left: 200,
            width: 100,
            height: 100,
            backgroundColor: "yellow",
            showhandler: false,
          },
        ],
        links: [],
        当前激活标签序号: null,
        当前激活标签类型: "",
        当前鼠标坐标: { x: "", y: "" },
        当前块引: "",
        自定义颜色数组: [],
        当前边框色: "",
        当前背景色: "",
        当前文字色: "",
        图片缩放倍数: "",
        当前激活id: "",
        当前反向链接列表: { "backmentions": [], "backlinks": [] },
        保存计数器: 1,
        定点添加: false,
        不可见标记数组: [],
        当前锚文本: "",
        当前正向链接列表: [],
        等待连接: false,
        数据库: {},
      };
    },
    watch: {
      图片缩放倍数: async function (val, oldval) {
        if (val) {
          let that = this;
          let image = this.$refs["image"];
          let id = this.数据源id;

          image.style.width = image.naturalWidth * that.图片缩放倍数 + "px";
          image.style.height = image.naturalHeight * that.图片缩放倍数 + "px";
          /*try {
            this.挂件自身元素.setAttribute("custom-resize", val);
          } catch (e) {}
          设置思源块属性(
            this.思源伺服ip,
            this.apitoken,
            id,
            "resize",
            JSON.stringify(val)
          );*/
          if (this.协同缩放) {
            this.标记数组.forEach((标记) => {
              标记.top = (标记.top * val) / oldval;
              标记.left = (标记.left * val) / oldval;
            });
          }
        }
      },
      图片源: async function (val) {
        if (val) {
          let that = this;
          console.log(this.图片源);
          let url = "http://" + this.思源伺服ip;
          let assetpath = this.图片源
            .replace(url, "")
            .replace("http://127.0.0.1:6806", "");
          let id = this.数据源id;
          /* try {
             this.挂件自身元素.setAttribute("custom-data-assets", assetpath);
           } catch (e) {}
           设置思源块属性(
             this.思源伺服ip,
             this.apitoken,
             id,
             "custom-data-assets",
             assetpath
           );*/

          if (val) {
            this.内部图片源 = val;
          }
          console.log(this.$refs["image"]);
          let image = this.$refs["image"];
          image.onload = function (event) {
            console.log(event.target);
            console.log(
              event.target.naturalWidth,
              event.target.naturalHeight
            );
            event.target.style.width =
              event.target.naturalWidth * that.图片缩放倍数 + "px";
            event.target.style.height =
              event.target.naturalHeight * that.图片缩放倍数 + "px";
          };
        }
      },
      内部图片源(val) {
        if (this.图片源 != val) {
          this.图片源 = val;
        }
      },
      当前激活标签序号(val, oldval) {
        console.log("序号", val);
        if (null != val) {
          let 标记数组 = this.标记数组
          this.当前块引 = this.标记数组[val]["def_block"];
          this.当前块引 = this.标记数组[this.当前激活标签序号]["def_block"];
          this.当前背景色 = this.标记数组[this.当前激活标签序号]["backgroundColor"];
          this.当前边框色 = this.标记数组[this.当前激活标签序号]["borderColor"];
          this.当前文字色 = this.标记数组[this.当前激活标签序号]["color"];
          this.当前锚文本 = this.标记数组[this.当前激活标签序号]["anchor"];
          if (this.等待连接) {
            let flag = true
            this.links.forEach(link => {
              if ((link.to == 标记数组[val]["id"] && link.from == 标记数组[oldval]["id"]) || (link.to == 标记数组[oldval]["id"] && link.from == 标记数组[val]["id"])) {
                flag = false
              }
            })
            if (flag) {
              this.links.push(
                {
                  id: Lute.NewNodeID(),
                  from: this.标记数组[oldval]["id"],
                  to: this.标记数组[val]["id"],
                  fromIndex: oldval,
                  toIndex: val,
                  color: "black",
                  width: "1",
                  label: "",
                  type: ""

                })
              console.log(this.links)
              this.等待连接 = false
            }
          }
        }
      },
      标记数组: {
        handler(val, oldval) {
          for (i = 0; i < this.links; i++) {
            console.log(this.links)
            let link = this.links[i]
            let 标记1 = this.以属性查找对象(this.标记数组, "id", link.from)
            let 标记2 = this.以属性查找对象(this.标记数组, "id", link.to)
            let 标记3 = this.标记数组[link['toIndex']]
            let 标记4 = this.标记数组[link['fromIdex']]
            if (!标记1.id || !标记2.id || !标记3.id || !标记4.id) {
              this.links.splice(i, 1);
              i = i - 1
              this.links = JSON.parse(JSON.stringify(this.links));
            }
          }

        },
        deep: true,
        immediate: true
      },
      links: {
        handler(val, oldval) {
          if (!this.$挂件模式()) {
            return null;
          }
          /* let id = this.数据源id;
           if (val) {
             try {
               this.挂件自身元素.setAttribute(
                 "custom-links",
                 JSON.stringify(val)
               );
             } catch (e) {}
             let that = this;
           }*/
        },
        deep: true,
      },

      数据源id: function (val, oldval) {
        console.log("new", val, "old", oldval)
        if (val != oldval && val && oldval) {
          this.初始化(val);
        }
      },
    },
    methods: {
      以属性查找对象(集合, 属性名, 属性值) {
        let obj = null
        集合.forEach(tag => {
          if (tag) {
            if (tag[属性名] == 属性值) {
              obj = tag
            }
          }
        }
        )
        return obj
      },
      计算折线路径: function (link) {
        //  console.log(link)
        let 起始标记 = this.以属性查找对象(this.标记数组, "id", link.from)
        let 结束标记 = this.以属性查找对象(this.标记数组, "id", link.to)
        if (起始标记 && 结束标记 && link) {
          //  console.log(起始标记,结束标记)
          if (!起始标记 || !结束标记) { delete link; return null }
          let 起始中心 = { x: 起始标记.left + 1 / 2 * 起始标记.width, y: 起始标记.top + 1 / 2 * 起始标记.height }
          let 结束中心 = { x: 结束标记.left + 1 / 2 * 结束标记.width, y: 结束标记.top + 1 / 2 * 结束标记.height }
          //   console.log(起始中心,结束中心)

          if (起始标记.folded) { 起始中心.x = 起始标记.left + 7.5; 起始中心.y = 起始标记.top + 7.5 }
          if (结束标记.folded) { 结束中心.x = 结束标记.left + 7.5; 结束中心.y = 结束标记.top + 7.5 }

          let 方向矢量 = { x: 结束中心.x - 起始中心.x, y: 结束中心.y - 起始中心.y }
          if (方向矢量.x == 0) { 方向矢量.x = 0.001 }
          if (方向矢量.y == 0) { 方向矢量.y = 0.0001 }

          let 起始节点 = {
            x: 起始中心.x + (起始标记.width / 2) * Math.sign(方向矢量.x),
            y: 起始中心.y + (起始标记.height / 2) * Math.sign(方向矢量.y)
          }
          let 结束节点 = {
            x: 结束中心.x - (结束标记.width / 2) * Math.sign(方向矢量.x),
            y: 结束中心.y - (结束标记.height / 2) * Math.sign(方向矢量.y)
          }

          let 起始y偏移 = 方向矢量.y * (起始标记.width / 2 / 方向矢量.x) * Math.sign(方向矢量.x)
          let 结束y偏移 = 方向矢量.y * (结束标记.width / 2 / 方向矢量.x) * Math.sign(方向矢量.x)

          if (Math.abs(起始y偏移) > 1 / 2 * 起始标记.height) { 起始y偏移 = 1 / 2 * 起始标记.height * Math.sign(起始y偏移) }
          if (Math.abs(结束y偏移) > 1 / 2 * 结束标记.height) { 结束y偏移 = 1 / 2 * 结束标记.height * Math.sign(起始y偏移) }
          起始节点.y = 起始中心.y + 起始y偏移
          结束节点.y = 结束中心.y - 结束y偏移

          let 起始x偏移 = 方向矢量.x * (起始标记.height / 2 / 方向矢量.y) * Math.sign(方向矢量.y)
          let 结束x偏移 = 方向矢量.x * (结束标记.height / 2 / 方向矢量.y) * Math.sign(方向矢量.y)

          if (Math.abs(起始x偏移) > 1 / 2 * 起始标记.width) { 起始x偏移 = 1 / 2 * 起始标记.width * Math.sign(起始x偏移) }
          if (Math.abs(结束x偏移) > 1 / 2 * 结束标记.width) { 结束x偏移 = 1 / 2 * 结束标记.width * Math.sign(起始x偏移) }
          起始节点.x = 起始中心.x + 起始x偏移
          结束节点.x = 结束中心.x - 结束x偏移

          let 路径矢量 = {
            x: 结束节点.x - 起始节点.x,
            y: 结束节点.y - 起始节点.y,

          }
          //console.log("起始",起始节点)
          let d = ""
          let mid = ""
          if (路径矢量["x"] * 路径矢量["x"] - 路径矢量["y"] * 路径矢量["y"] >= 0) {
            d = `
          M ${起始节点.x} ${起始节点.y}
          l ${路径矢量["x"] / 2}  0
          l 0  ${路径矢量["y"] / 2}
          l 0  ${路径矢量["y"] / 2}
          l ${路径矢量["x"] / 2}  0
          `

          }
          else {
            d = `
          M ${起始节点.x} ${起始节点.y}
          l 0  ${路径矢量["y"] / 2}
          l ${路径矢量["x"] / 2}  0
          l ${路径矢量["x"] / 2}  0
          l 0  ${路径矢量["y"] / 2}
          `
          }
          if (link.type == "simpleLine") {
            d = `
            M ${起始节点.x} ${起始节点.y}
        
           l ${路径矢量["x"]}  ${路径矢量["y"]}
          `
          }
          mid = { x: 起始节点.x + 路径矢量.x / 2, y: 起始节点.y + 路径矢量.y / 2 }
          // console.log(d,mid)
          return { "d": d, "mid": mid }
        }
        else { return { "d": "", "mid": { x: 0, y: 0 } } }
      },
      黏贴内容: function ($event) {
        let clipboardData = $event.clipboardData;

        if (!(clipboardData && clipboardData.items)) {
          return;
        }
        for (var i = 0, len = clipboardData.items.length; i < len; i++) {
          var item = clipboardData.items[i];
          if (item.kind === "string" && item.type == "text/plain") {
            item.getAsString((str) => {
              console.log(str);
              this.解析剪贴板内容(str + "");
            });
          }
        }
      },
      解析剪贴板内容: async function (str) {
        let 锚文本 = await 获取思源块链接锚文本(
          this.思源伺服ip,
          this.apitokn,
          str
        );
        if (锚文本 != "解析错误") {
          let 空标签对象 = {
            def_block: str,
            anchor: "",
            top: window.pageYOffset + this.当前鼠标坐标.y,
            left: window.pageXOffset + this.当前鼠标坐标.x,
            width: 100,
            height: 100,
            backgroundColor: "yellow",
            borderColor: "red",
            showhandler: false,
            color: "balck",
            folded: false,
            id: Lute.NewNodeID(),

          };
          this.标记数组.push(空标签对象);
        } else {
          let 空标签对象 = {
            def_block: "",
            anchor: str,
            top: window.pageYOffset + this.当前鼠标坐标.y,
            left: window.pageXOffset + this.当前鼠标坐标.x,
            width: 100,
            height: 100,
            backgroundColor: "yellow",
            borderColor: "red",
            showhandler: false,
            color: "balck",
            folded: false,
            id: Lute.NewNodeID(),

          };
          this.标记数组.push(空标签对象);
        }
      },
      展开链接面板: async function (index) {
        let id = this.标记数组[index]["def_block"];
        let 反向链接列表 = await this.以id获取反向链接(id);
        if (反向链接列表) {
          this.当前反向链接列表 = 反向链接列表["data"];
          this.当前反向链接列表["index"] = index;
          console.log(this.当前反向链接列表);
        }
      },
      初始化: async function (val) {
        let 数据源属性 = {}
        if (this.$挂件模式()) {
          this.挂件自身元素 = window.frameElement.parentElement.parentElement;
          let 图片源 =
            "http://" +
            this.思源伺服ip +
            this.挂件自身元素.getAttribute("custom-data-assets");
          if (图片源) {
            this.图片格式 = 图片源
              .substring(图片源.lastIndexOf("."), 图片源.length)
              .replace('"', "");
          }
          this.内部图片源 = 图片源 + "";
          this.获取标记数组();
          this.$获取思源主界面主题(this.主界面);
          if (this.挂件自身元素.getAttribute("custom-resize")) {
            this.图片缩放倍数 = parseFloat(
              this.挂件自身元素.getAttribute("custom-resize")
            ).toFixed(2);
          }
          this.数据源id = this.挂件自身元素.getAttribute("data-node-id");
        } else {
          let url参数 = this.$解析url(window.location.href);
          console.log(url参数);
          let 数据源id = url参数.id;
          if (数据源id) {
            this.数据源id = 数据源id;
          }
          let 临时数组 = await this.$以id数组通过sql形式获取思源块信息数组([
            数据源id,
          ]);
          //  let 数据源属性 = await 以id获取思源块属性(this.思源伺服ip,this.apitoken,数据源id)
          数据源属性 = await this.获取块属性(数据源id);
          console.log(数据源属性);
          if (数据源属性) {
            try {
              this.内部图片源 = 数据源属性["custom-data-assets"];
              this.标记数组 = JSON.parse(
                this.$html转义(数据源属性["custom-tagarray"])
              );
              this.links = JSON.parse(
                this.$html转义(数据源属性["custom-links"])
              )
            } catch (e) { console.log(e) }
            console.log(this.标记数组);
            if (
              数据源属性["custom-resize"] &&
              数据源属性["custom-resize"] > 0
            ) {
              this.图片缩放倍数 = parseFloat(
                数据源属性["custom-resize"]
              ).toFixed(2);
              console.log(数据源属性["custom-resize"]);
            }
            console.log(数据源属性);
          }
        }
        let that = this
        let filepath = ""
        filepath = 数据源属性["data-assets"]
        if (this.$挂件模式()) { filepath = this.挂件自身元素.getAttribute("data-assets") }
        let url = 'http://' + that.思源伺服ip + '/' + filepath
        await axios.get(url).then((res) => {
          文件数据 = res.data
          if (文件数据["tagarray"]) {

            try {
              this.links = 文件数据.links.filter(function (a) { return a })

              this.标记数组 = 文件数据.tagarray.filter(function (a) { return a })
              this.图片缩放倍数 = 文件数据.resize

            } catch (e) { return null }

          }
        })
        if (!this.标记数组) { this.标记数组 = [] }
        if (!this.links) { this.links = [] }
        this.标记数组.forEach(tag => {
          if (!tag.id) {
            tag.id = Lute.NewNodeID();
            console.log(tag.id)
          }
          if (!tag.markdown) {
            tag.markdown = "## 此处输入内容";
          }

          tag.def_block = tag.def_block.replace("((", "").replace("))", "");
          console.log(tag)
        })
        this.links.forEach(link => {
          if (!link.id || link.id.length < 5) {
            link.id = Lute.NewNodeID();
            console.log(link.id)
          }
          if (this.标记数组[link.from]) { link.from = this.标记数组[link.from]["id"] }
          if (this.标记数组[link.to]) { link.to = this.标记数组[link.to]["id"] }
          console.log(link)
        })


      },
      定位至标记(标记对象) {
        window.scrollTo(
          标记对象.left - window.innerWidth / 2,
          标记对象.top - window.innerHeight / 2
        );
      },
      以id获取反向链接: async function (val) {
        if (val) {
          let id = val.replace("((", "").replace("))", "");
          let 当前反向链接列表 = await 以id获取反向链接(
            this.思源伺服ip,
            this.apitoken,
            id
          );
          return 当前反向链接列表;
        }
      },
      以id获取块内容: async function (id) {
        let 数据源id = this.挂件自身元素.getAttribute("data-node-id");
        let 临时属性数组 = await this.$以id数组通过sql形式获取思源块信息数组([
          数据源id,
        ]);
        let 挂件自身属性 = 临时属性数组[0];
        let 当前文档id = 挂件自身属性["root_id"];
        let 外部id数组 = [数据源id, 当前文档id];
        let 块内容 = await this.$以id获取块内容(外部id数组, id);
        console.log(块内容["blocks"][0]);
      },

      打开右键菜单() {
        this.显示菜单 = true;
      },
      获取标记数组() {
        let tempArryStr = "";
        if (this.挂件自身元素.getAttribute("custom-tagarry")) {
          tempArryStr = this.挂件自身元素.getAttribute("custom-tagarry");
        }
        if (this.挂件自身元素.getAttribute("custom-tagarray")) {
          tempArryStr = this.挂件自身元素.getAttribute("custom-tagarray");
        }
        try {
          tempArryStr = this.$html转义(tempArryStr);
          templinksStr = this.$html转义(links);
          this.标记数组 = JSON.parse(tempArryStr);
          this.links = JSON.parse(templinksStr);

          this.图片缩放倍数 = this.挂件自身元素.getAttribute("custom-resize");
        } catch (e) { }
        console.log(this.标记数组);
        this.标记数组 = JSON.parse(JSON.stringify(this.标记数组));
      },
      移除标签(标号) {
        for (i = 0; i < this.links.length; i++) {
          let 标记 = this.标记数组[标号]

          let link = this.links[i]
          if (link.from == 标记.id || link.to == 标记.id) {
            this.links.splice(i, 1)
            console.log(i, link)
          }
        }

        this.标记数组.splice(标号, 1);

        this.当前激活标签序号 = null



      },


      计算坐标($event) {

        this.当前鼠标坐标.x = $event.clientX;
        this.当前鼠标坐标.y = $event.clientY;

        this.保存计数器 = this.保存计数器 + 1;
        if (this.保存计数器 >= 50) {
          this.保存标记();
          this.保存计数器 = 1
        }
        this.计算可见性();

        this.窗口大小 = {
          width: window.pageXOffset + $event.clientX + window.innerWidth,
          height: window.pageYOffset + $event.clientY + window.innerHeight,
        };
      },

      保存标记: async function () {

        let that = this
        let 文件数据 = {}
        文件数据.tagarray = this.标记数组
        文件数据.links = this.links
        文件数据.backgroundimage = this.图片源
        文件数据.resize = this.图片缩放倍数
        console.log(文件数据)
        let 数据blob = new Blob([JSON.stringify(文件数据)], { type: 'application/json' })
        let 文件 = new File([数据blob], `dataof${this.数据源id}.cctag`, { lastModified: Date.now() })
        let data = new FormData
        data.append('assetsDirPath', '/assets/')
        data.append('file[]', 文件)
        let url = 'http://' + that.思源伺服ip + '/api/asset/upload'
        let filepath = ""
        await fetch(url, {
          body: data,
          method: 'POST',
          headers: { 'Authorization': 'Token ' + that.apitoken },
        }).then(
          function (response) {
            console.log(response)
            return response.json()
          }
        ).then(function (resData) {
          console.log(resData)
          let succMap = resData['data']['succMap']
          console.log(succMap)
          for (item in succMap) {
            filepath = filepath + succMap[item]
            console.log(filepath)
          }
          //that.挂件自身元素.setAttribute('custom-data-assets',filepath)
        })
        await 设置思源块属性(that.思源伺服ip, that.apitoken, that.数据源id, 'data-assets', filepath)
        try { that.挂件自身元素.setAttribute('data-assets', filepath) }
        catch (e) { }
        ;

      },
      计算可见性: function () {
        let 不可见标记数组 = [];
        for (i = 0; i < this.标记数组.length; i++) {
          let 标记 = JSON.parse(JSON.stringify(this.标记数组[i]));
          if (标记) {
            标记.index = i;

            if (
              window.pageYOffset > 标记.top ||
              window.pageYOffset + window.innerHeight < 标记.top ||
              window.pageXOffset > 标记.left ||
              window.pageXOffset + window.innerWidth < 标记.left
            ) {
              不可见标记数组.push(标记);
            }
          }
        }

        this.不可见标记数组 = Array.from(new Set(不可见标记数组));
      },
      设定当前标记() {
        let that = this;
        this.$set(
          this.标记数组[that.当前激活标签序号],
          "def_block",
          this.当前块引
        );
        this.标记数组[that.当前激活标签序号]["backgroundColor"] =
          this.当前背景色;
        this.标记数组[that.当前激活标签序号]["borderColor"] = this.当前边框色;
        this.标记数组[that.当前激活标签序号]["color"] = this.当前文字色;
        this.标记数组[that.当前激活标签序号]["anchor"] = this.当前锚文本;
        //this.当前激活标签序号 = null;
        this.当前块引 = "";
        this.标记数组 = JSON.parse(JSON.stringify(this.标记数组));
      },
      增加标记: function () {
        if (this.定点添加) {
          let 空标签对象 = {
            def_block: "",
            anchor: "锚文本为空时显示来源块内容",
            top: window.pageYOffset + this.当前鼠标坐标.y,
            left: window.pageXOffset + this.当前鼠标坐标.x,
            width: 100,
            height: 100,
            backgroundColor: "yellow",
            borderColor: "red",
            showhandler: false,
            color: "balck",
            folded: true,
            id: Lute.NewNodeID(),
          };
          this.标记数组.push(空标签对象);
          // this.标记数组 = JSON.parse(JSON.stringify(this.标记数组));
          console.log(this.标记数组)
          this.定点添加 = false;
        }
      },

      获取块属性: async function (id) {
        let that = this;
        当前块信息 = await that.通过id获取文档属性(id);
        当前块内容对象 = await 以id获取思源块信息(
          that.思源伺服ip,
          that.apitoken,
          id
        );
        let 当前块属性 = 当前块信息["ial"];
        当前块信息 = 当前块信息;

        当前块属性["type"] = 当前块内容对象["type"];
        return 当前块属性;

      },
      获取正向链接: async function (i) {

        let that = this
        let id = that.标记数组[i]["def_block"]
        let 思源伺服ip = window.location.host
        let obj = {}
        let sql = `select * from blocks where id in (select def_block_id from refs where block_id = '${id}')`
        obj = await 以sql向思源请求块数据(思源伺服ip, this.apitoken, sql)
        console.log(obj)
        this.当前正向链接列表 = obj
      },
      通过id获取文档属性: async function (id) {
        let that = this;
        let obj = {};
        await axios({
          method: "post",
          url: "http://" + that.思源伺服ip + "/api/block/getDocInfo",
          headers: { Authorization: "Token " + that.apitoken },
          data: { id: `${id}` },
        }).then((result) => {
          //   console.log("aaa",result.data)

          obj = result.data["data"];
        });
        return obj;
      },
      打开新窗口() {
        this.$窗口内打开超链接(
          `http://${this.思源伺服ip}/widgets/cc-image-tag/?id=${this.数据源id}`
        );
      },

    },
  });
</script>
<style>
  .el-popover.tagpoper,
  .el-popover .el-popper.tagpoper {
    padding: 0;
    background-color: transparent;
    border: none;
  }

  .el-icon-browser {
    background: url("/widgets/cc-baselib/icons/browser-o.svg") center no-repeat;
    background-size: contain;
  }

  .el-icon-browser::before {
    content: "\8d3a";
    font-size: 14px;
    visibility: hidden;
  }

  .el-icon-siyuan {
    background: url("/widgets/cc-baselib/icons/siyuan.svg") center no-repeat;
    background-size: contain;
  }

  .el-icon-siyuan::before {
    content: "\8d3a";
    font-size: 14px;
    visibility: hidden;
  }

  .draggable {
    padding: 0px;
  }
</style>

</html>